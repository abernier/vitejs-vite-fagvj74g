import * as THREE from 'three'

import { ComponentProps, ElementRef, forwardRef, useEffect, useRef, useState } from 'react'
import { Canvas, useFrame, useThree } from '@react-three/fiber'
import { useControls } from 'leva'
import {
  FaceLandmarker,
  PerspectiveCamera,
  Helper,
  CameraControls,
  useGLTF,
  Center,
  Resize,
  Environment,
  Sphere,
} from '@react-three/drei'
import { suspend } from 'suspend-react'

const city = import('@pmndrs/assets/hdri/city.exr')
const suzi = import(`@pmndrs/assets/models/suzi.glb`)

import { FaceControls } from './tmp/FaceControls'
import { Raycaster } from './tmp/Raycaster'

export default function App() {
  return (
    <>
      <Canvas camera={{ position: [-1.5, 1, 2] }} shadows>
        <FaceLandmarker>
          <Scene />
        </FaceLandmarker>
      </Canvas>
    </>
  )
}

function Tangent({
  hit,
  ...props
}: {
  hit: THREE.Intersection | null
} & ComponentProps<'group'>) {
  const camera = useThree((state) => state.camera)

  const groupRef = useRef<THREE.Group>(null)

  //
  // https://chatgpt.com/share/675d6e25-1e0c-8011-b0a9-986bec7de762
  //

  useEffect(() => {
    if (!groupRef.current || !hit) return
    groupRef.current.position.copy(hit.point)

    // Oriente le groupe selon la normale du hit
    const normalMatrix = new THREE.Matrix4().lookAt(
      hit.point,
      hit.point.clone().add(hit.face?.normal || new THREE.Vector3(0, 0, 0)),
      camera.up
    )
    groupRef.current.quaternion.setFromRotationMatrix(normalMatrix)
  }, [camera.up, hit])

  return <group ref={groupRef} {...props} />
}

function Scene() {
  const gui = useControls({
    camera: { value: 'cc', options: ['user', 'cc'] },
    model: { value: 'pasteque', options: ['suzi', 'pasteque', 'ball'] },
    origin: { value: [-4, 0.1, 0] },
    direction: { value: [1, 0, 0] },
    distance: { value: 1, min: 0, max: 10 },
  })
  const debug = gui.camera === 'cc'

  const [userCam, setUserCam] = useState<THREE.PerspectiveCamera | null>(null)

  const raycasterRef = useRef<ElementRef<typeof Raycaster>>(null)
  const [hit, setHit] = useState<THREE.Intersection | null>(null)
  const d = gui.distance

  const sphereRef = useRef<THREE.Mesh>(null)
  const target2Ref = useRef<THREE.Group>(null)
  const wrapperRef = useRef<THREE.Group>(null)

  const [pos] = useState(new THREE.Vector3())
  const [quat] = useState(new THREE.Quaternion())
  useFrame(() => {
    if (!raycasterRef.current) return

    const { hitsRef } = raycasterRef.current

    if (!sphereRef.current || !hitsRef.current) return
    const hit = hitsRef.current[0]
    if (!hit) return
    setHit(hit)
    sphereRef.current.position.copy(hit.point)

    target2Ref.current?.getWorldPosition(pos)
    target2Ref.current?.getWorldQuaternion(quat)

    wrapperRef.current?.position.copy(pos)
    wrapperRef.current?.quaternion.copy(quat)
  })

  return (
    <>
      <color attach="background" args={['#403c3f']} />
      {debug && <axesHelper raycast={() => null} />}
      {debug && <gridHelper raycast={() => null} />}

      <Center top key={gui.model}>
        <Resize width scale={2} key={gui.model}>
          {gui.model === 'pasteque' && <Pasteque rotation-z={(7 * Math.PI) / 180} rotation-x={(-1 * Math.PI) / 180} />}
          {gui.model === 'suzi' && <Suzi rotation={[-0.63, 0, 0]} />}
          {gui.model === 'ball' && (
            <Sphere>
              <meshStandardMaterial color="#eee" />
            </Sphere>
          )}
        </Resize>
      </Center>

      <Raycaster ref={raycasterRef} origin={gui.origin} direction={gui.direction} near={1} far={8} helper={[0]} />
      <mesh ref={sphereRef} raycast={() => null}>
        <sphereGeometry args={[0.04]} />
        <meshBasicMaterial color="red" />
      </mesh>

      <Tangent hit={hit}>
        <group scale-z={-1} position-z={-d}>
          <axesHelper raycast={() => null} />
          <group ref={target2Ref} />
        </group>
      </Tangent>

      <PerspectiveCamera ref={(cam) => setUserCam(cam)} makeDefault={gui.camera === 'user'} fov={40} near={0.1} far={5}>
        {debug && <Helper type={THREE.CameraHelper} />}
      </PerspectiveCamera>

      <group ref={wrapperRef}>
        <FaceControls
          camera={userCam ?? undefined}
          makeDefault
          offset={false}
          // smoothTime={0.2}
          // debug={debug}
        />
      </group>
      <CameraControls />

      <Environment files={suspend(city).default} />
    </>
  )
}

function Pasteque(props: ComponentProps<'group'>) {
  /*
  Auto-generated by: https://github.com/pmndrs/gltfjsx
  Author: Omar Faruq Tawsif (https://sketchfab.com/omarfaruqtawsif32)
  License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
  Source: https://sketchfab.com/3d-models/painterly-brushwork-study-with-pchans-painting-e0166b7b9bff42e9a6b39ac1f08ce53c
  Title: Painterly brushwork study with Pchan's painting
  */

  const { nodes, materials } = useGLTF(
    'https://storage.googleapis.com/abernier-portfolio/painterly_brushwork_study_with_pchans_painting.glb'
  ) as any

  return (
    <group {...props} dispose={null}>
      <group rotation={[-1.557, 0.116, -0.487]} scale={0.032}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_4.geometry}
            material={materials['Material.001']}
            position={[0.265, 0.744, 0.211]}
            rotation={[2.033, -0.663, 2.801]}
          ></mesh>

          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_6.geometry}
            material={materials['Material.001']}
            position={[-0.374, -0.079, -0.609]}
            rotation={[2.097, -0.895, -1.122]}
            scale={0.829}
          ></mesh>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_8.geometry}
            material={materials['Material.001']}
            position={[0.602, -0.028, -0.553]}
            rotation={[-1.44, -0.68, 2.389]}
            scale={0.994}
          ></mesh>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_10.geometry}
            material={materials['Material.001']}
            position={[0.125, -0.204, -0.449]}
            scale={1.358}
          />
        </group>
      </group>
    </group>
  )
}

const Suzi = forwardRef<ElementRef<'mesh'>, ComponentProps<'mesh'>>((props, ref) => {
  const { nodes } = useGLTF(suspend(suzi).default)
  return (
    <>
      <mesh ref={ref} castShadow receiveShadow geometry={nodes.mesh.geometry} {...props}>
        <meshStandardMaterial color="#9d4b4b" />
      </mesh>
    </>
  )
})
